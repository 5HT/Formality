// Efficient "C-like" arrays using perfect binary trees

// Example usage of this library
def Arr.ex:

  // Allocates a new array and creates its methods
  let dpt    = ~16
  let pbt    = PBT.16
  let add    = Num.boxed_add
  dup arr    = (Arr.init pbt ##0)   // ~133k graph-rewrites to alloc 65536 zeros
  dup write  = (Arr.write dpt)  // ~650 graph-rewrites per write with dpt=16
  dup update = (Arr.update dpt) // ~650 graph-rewrites per update with dpt=16
  dup read   = (Arr.read dpt)   // ~650 graph-rewrites per read with dpt=16

  // Performs some writes and reads
  # let arr      = (write 0 #10 arr)       // arr[0] = 10
    let arr      = (write 1 #12 arr)       // arr[1] = 12
    let arr      = (update 2 (add #8) arr) // arr[2] += 8
    let arr      = (write 3 #7 arr)        // arr[1] = 12
    get [arr, a] = (read 0 arr)            // a = arr[0]
    get [arr, b] = (read 1 arr)            // b = arr[1]
    get [arr, c] = (read 2 arr)            // c = arr[2]
    get [arr, d] = (read 3 arr)            // c = arr[2]
    ["arr[0] + arr[1] + arr[2]:", (add (add a b) c)]

// Example of folding over an array
def Arr.ex.fold:
  dup fold  = (Arr.fold PBT.3 #{a b}|a + b| #{x}|x * 2|)
  # (fold [[[1,2],[3,4]],[[5,6],[7,8]]])

// Arr. with
// | Searches an element, updates it, returns the updated
// | array and a value that can depend on the element
// : {-A  : Type}             -- Type of the elements
//   {dpt : CNat}             -- Length of array = 2^dpt
//   ! {path : Num}           -- Num storing path to element
//     {fn   : {x : A} (A,A)} -- Receives found element, returns an element to replace it by, and a return value.
//     {(Array dpt A)}        -- The array to be queried
//     ((Array dpt A), A)     -- The updated array, and return value returned by `fn`.
def Arr.with: {dpt}
  let init = {path fn} fn
  let loop = {cont path fn}
    cpy path = path
    get [swap0,swap1] =
      if |path % 2|
      then: [{x}x, {x}x]
      else: [Pair.swap, Pair.swap]
    (cont |path / 2| {arr}
      get [a,b] = (swap0 arr)
      get [b,x] = (fn b)
      [(swap1 [a,b]), x])
  let stop = {func} func
  dup fold = (for dpt #init #loop #stop)
  # {path fn arr} (fold path fn arr)

// Arr.update
// | Applies a function to an element
// : {-A  : Type}             -- Type of the elements
//   {dpt : CNat}             -- Length of array = 2^dpt
//   ! {path : Num}           -- Num storing path to element
//     {fn   : {x : A} A}     -- Update function
//     {arr  : (Array dpt A)} -- The array to be updated
//     (Array dpt A)          -- The updated array, and return value returned by `fn`.
def Arr.update: {dpt}
  dup with = (Arr.with dpt) 
  # {path f arr} (fst (with path {x}[(f x), 0] arr))

// Arr.read
// | Returns a copy of an element and returns the array unchanged
// : {-A  : Type}              -- Type of the elements
//   {dpt : CNat}              -- Length of array = 2^dpt
//   ! {path : Num}            -- Num storing path to element
//     {arr  : (Array dpt !A)} -- The array to be read
//     {(Array dpt !A),!A}    -- The array itself, and a copy of the element
def Arr.read: {dpt}
  dup with = (Arr.with dpt)
  # {path arr}
    let f = {x}
      dup x = x
      [#x, #x]
    (with path f arr)

// peek
// | Like read, but on numeric, unboxed arrays
// : {-A  : Type}               -- Type of the elements
//   {dpt : CNat}               -- Length of array = 2^dpt
//   ! {path : Num}             -- Num storing path to element
//     {arr  : (Array dpt Num)} -- The array to be read
//     {(Array dpt Num), Num}   -- The array itself, and a copy of the element
def Arr.peek: {dpt}
  dup with = (Arr.with dpt)
  # {path arr}
    let f = {x}
      cpy x = x
      [x, x]
    (with path f arr)

// Arr.take
// | Takes an element out of an array and returns it
// : {-A  : Type}             -- Type of the elements
//   {dpt : CNat}             -- Length of array = 2^dpt
//   ! {path : Num}           -- Num storing path to element
//     {val  : A}             -- New value to put in place of old
//     {arr  : (Array dpt A)} -- The array to be taken
//     {(Array dpt A),A}      -- The updated array and the take element
def Arr.take: {dpt}
  dup with = (Arr.with dpt)
  # {path val arr}
    (with path {x}[val,x] arr)

// Arr.write
// | Overwrites an element of the array
// : {-A  : Type}             -- Type of hte elements
//   {dpt : CNat}             -- Length of the array = 2^dpt
//   ! {path : Num}           -- Num storing path to element
//     {arr  : (Array dpt A)} -- Array to be written
//     {val  : A}             -- Value to be written
//     (Array dpt A)          -- The overwritten array
def Arr.write: {dpt}
  dup update = (Arr.update dpt)
  # {path val} (update path {x}val)

// Arr.test_1024
// : (Array ~10 Num)
def Arr.test_1024:
  let a = [1,1]
  let b = [a,a]
  let c = [b,b]
  let d = [c,c]
  let e = [d,d]
  let f = [e,e]
  let g = [f,f]
  let h = [g,g]
  let i = [h,h]
  [i,i]

// Arr.fold
// : {-A  : Type}
//   {-P   : Type}
//   {dpt  : PBT}
//   {Node : !{lft : A} {rgt : A} P}
//   {Leaf : !{val : A} P}
//   ! {arr  : !(Array dpt A)}
//     P
def Arr.fold: {pbt Node Leaf}
  dup Node = Node
  dup Leaf = Leaf
  let leaf = # {val} (Leaf val)
  let node = # {lft rgt arr}
    get [arr_lft, arr_rgt] = arr
    (Node (lft arr_lft) (rgt arr_rgt))
  (pbt node leaf)

// Arr.init
// | Generates an array with 2^dpt copies of val
// : {-A  : Type}
//   {dpt : PBT}
//   {val : !A}
//   ! (Array dpt A)
def Arr.init: {dpt val}
  dup val = val
  (dpt #{a b}[a,b] #val)

def arr: Arr.ex
