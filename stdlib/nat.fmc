// Natural numbers

def Nat.zero:
  {Succ Zero}
  Zero

def Nat.succ: {pred}
  {Succ Zero}
  (Succ pred)

def Nat.to_chars: {n}
  let call = {go} {nat}
    let case_succ = {n} (List.concat (to_chars "S") (go n))
    let case_zero = (to_chars "Z")
    (nat case_succ case_zero)
  let stop = {nat} List.nil
  (n #call #stop)

def Nat.to_string: {n}
  dup func = (Nat.to_chars n)
  # {n} (from_chars (func n))

def Nat.copy: {n}
  let call = {go} {nat}
    let case_succ = {n ns}
      get [n0, n1] = ns
      (go n [(Nat.succ n0), (Nat.succ n1)])
    let case_zero = {ns} ns
    (nat case_succ case_zero)
  let stop = {n ns} ns
  dup func = (rec n #call #stop)
  # {n} (func n [Nat.zero, Nat.zero])

def Cmp.lt: {Lt Eq Gt} Lt
def Cmp.eq: {Lt Eq Gt} Eq
def Cmp.gt: {Lt Eq Gt} Gt

def Nat.compare: {n}
  let call = {go} {a}
    let case_a_succ = {a_pred} {b}
      let case_b_succ = {b_pred} (go a_pred b_pred)
      let case_b_zero = Cmp.gt
      (b case_b_succ case_b_zero)
    let case_a_zero = {b}
      let case_b_succ = {b_pred} Cmp.lt
      let case_b_zero = Cmp.eq
      (b case_b_succ case_b_zero)
    (a case_a_succ case_a_zero)
  let stop = {a b} Cmp.eq
  (rec n #call #stop)

def nat:
  dup cmp = (Nat.compare ~6)
  let a = (Nat.succ (Nat.succ Nat.zero))
  let b = (Nat.succ (Nat.succ (Nat.succ Nat.zero)))
  # (cmp a b)
