// Bits.ex
// | This example achieves the fusion effect in a recursive function. In order
// | for the optimization to work (allowing us to apply `Bits.inc` N times in
// | O(log(N)) time, an exponential speedup), we need to call `Bits.id`
// | afterwards, otherwise we get back to O(N).
def Bits.ex:
  let len = ~32
  dup val = (rec len #Bits.o #Bits.e)
  dup inc = (Bits.inc len)
  dup bid = (Bits.id len)
  dup fun = (~10000 #inc)
  # (bid (inc val))

// Bits
// | Bitstrings
// : $self
//   {P : Bits -> Type} ->
//   {o : {bs : Bits} -> (P (Bits.o bs))} ->
//   {i : {bs : Bits} -> (P (Bits.i bs))} ->
//   {e : (P Bits.e)}
//   (P self)
def Bits.o: {bs} {o i e} (o bs)
def Bits.i: {bs} {o i e} (i bs)
def Bits.e:      {o i e} e

// Bits.inc
// | Increments a bit-string by 1
// : {n : Nat} ->
//   ! {bs : Bits} ->
//     Bits
def Bits.inc: {n}
  let call = {go bs} {o i e}
    let case_o = i
    let case_i = {x} (o (go x))
    let case_e = e
    (bs case_o case_i case_e)
  let stop = {bs} bs
  (rec n #call #stop)

// Bits.id
// | Returns the same bit-string
// : {n : Nat} ->
//   ! {bs : Bits} ->
//     Bits
def Bits.id: {n}
  let call = {go bs}
    let case_o = Bits.o
    let case_i = Bits.i
    let case_e = Bits.e
    (bs case_o case_i case_e)
  let stop = {bs} bs
  (rec n #call #stop)
