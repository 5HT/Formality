// TODO: continue the update of this file

def List.ex: (reverse (map (List.cons #3 (List.cons #4 (List.cons #7 (List.cons #2 (List.cons #0 List.nil))))) #{x} |x * 2|))
def List.ex.foldr: (foldr example_list #{x y} |x + y|)

def List.cons: {x xs}
  {Cons}
  dup x    = x
  dup Cons = Cons
  dup func = (xs #Cons)
  # {nil} (Cons x (func nil))

def List.nil:
  {Cons}
  # {nil} nil

def List.to_stack: {list}
  dup F = (list #Cons)
  # (F nil)

def List.build: {len init loop} {cons}
  dup loop = loop
  dup init = init
  dup cons = cons
  dup fold = (len #{list state}
    get [state, element] = (loop state)
    (cons element (list state)))
  # {nil} (fold {state}nil init)

// Concatenates two lists
def List.concat: {a b}
  {Cons}
  dup Cons = Cons
  dup append-a = (a #Cons)
  dup append-b = (b #Cons)
  # {nil} (append-a (append-b nil))

// Converts Scott to Church in O(len).
def List.fold_f: {len Cons}
  dup Cons = Cons
  let func = {cont list}
    let case_cons = {head tail nil} (Cons head (cont tail nil))
    let case_nil  = {nil} nil
    (list case_cons case_nil)
  dup fold = (len #func)
  # {nil list} (fold {tail}{nil}nil list nil)

// Non-fused version of the function above.
def List.fold: {len}
  dup fold_f = (List.fold_f len #List.cons)
  # {list} (fold_f List.nil list)

def List.map: {as f Cons}
  dup f = f
  dup Cons = Cons
  let case_cons = {a} (Cons (f a))
  dup A = (as #case_cons)
  # {Nil} (A Nil)

def List.reverse:
  {as}
  let iterate = {xs ys Cons}
    dup Cons = Cons
    dup rec = (xs #{x h p} (h (Cons x p)))
    dup p = (ys #Cons)
    #{N} (rec {p} p (p N))
  (iterate as List.nil)

def List.filter: {xs p}
  dup p = p
  {Cons}
  dup Cons = Cons
  dup rec = (xs #{x h}
    dup x = x
    (p #x {r} (Cons #x r) {r} r h))
  #{N} (rec N)

def List.foldl: {as op}
  dup op = op
  dup rec = (as #{a h} (op h a))
  #{b} (rec b)

def List.foldr: {as op}
  dup op = op
  dup rec = (as #{a h} (op a h))
  # {b} (rec b)
