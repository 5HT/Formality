// Term
def Lam: {body}      {Lam App Var} (Lam body)
def App: {func argm} {Lam App Var} (App func argm)
def Var: {indx}      {Lam App Var} (Var indx)

def Term.ex:

  // Library functions
  let max_len   = ~65536
  dup reduce    = (Term.reduce max_len)
  dup normal    = (Term.normal max_len #reduce)
  dup quote     = (Term.quote max_len)
  dup to_string = (Term.quoted.to_string max_len)

  // Example terms
  dup TRUE  = #(Lam {t} (Lam {f} t))
  dup FALSE = #(Lam {t} (Lam {f} f))
  dup NOT2  = #(Lam {b} (App (App b FALSE) TRUE))
  dup NOT   = #(Lam {b} (Lam {t} (Lam {f} (App (App b f) t))))
  dup NOTS  = (~1000 #(App NOT2))

  # (to_string (normal (reduce (NOTS TRUE))))

def Term.quote: {mlen}
  let call = {go indx term}
    cpy indx = indx
    let case_lam = {body} {go}
      get [go, body] = (go |indx + 1| (body (Var indx)))
      [go, (Lam body)]
    let case_app = {func argm} {go}
      get [go, func] = (go indx func)
      get [go, argm] = (go indx argm)
      [go, (App func argm)]
    let case_var = {indx} {go}
      [go, (Var indx)]
    (term case_lam case_app case_var go)
  let stop = {indx term}
    [{x}x, (Var 0)]
  dup func = (rec mlen #call #stop)
  # {term}
    (snd (func 0 term))

def Term.quoted.to_string: {mlen}
  let name = {indx}
    let char = (Num.box_byte ||indx % 26| + 97|)
    (List.cons char List.nil)
  let call = {go term}
    let case_lam = {body} {go}
      get [go, body] = (go body)
      let text = List.nil
      let text = (List.concat text (to_chars "{}"))
      let text = (List.concat text body)
      [go, text]
    let case_app = {func argm} {go}
      get [go, func] = (go func)
      get [go, argm] = (go argm)
      let text = List.nil
      let text = (List.concat text (to_chars "("))
      let text = (List.concat text func)
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text argm)
      let text = (List.concat text (to_chars ")"))
      [go, text]
    let case_var = {indx} {go}
      [go, (name indx)]
    (term case_lam case_app case_var go)
  let stop = {term}
    [{x}x, term]
  dup func = (rec mlen #call #stop)
  # {term}
    (from_chars (snd (func term)))

def Term.reduce: {mlen}
  let call = {go term}
    let case_lam = {body} {go}
      [go, (Lam body)]
    let case_app = {func argm} {go}
      let case_lam   = {f_body}        {argm go} get [go, body] = (go (f_body argm)) [go, body]
      let case_app   = {f_func f_argm} {argm go} get [go, argm] = (go argm) [go, (App (App f_func f_argm) argm)]
      let case_var   = {f_indx}        {argm go} get [go, argm] = (go argm) [go, (App (Var f_indx) argm)]
      get [go, func] = (go func)
      (func case_lam case_app case_var argm go)
    let case_var = {indx} {go}
      [go, (Var indx)]
    (term case_lam case_app case_var go)
  let stop = {term}
    [{x}x, (Var 0)]
  dup func = (rec mlen #call #stop)
  # {term}
    (snd (func term))

def Term.normal: {mlen redx}
  dup redx = redx
  let call = {go indx term}
    cpy indx = indx
    let case_lam = {body} {go}
      get [go, body] = (go |indx + 1| (body (Var indx)))
      [go, (Lam body)]
    let case_app = {func argm} {go}
      get [go, func] = (go indx func)
      get [go, argm] = (go indx argm)
      [go, (App func argm)]
    let case_var = {indx} {go}
      [go, (Var indx)]
    let term = (redx term)
    (term case_lam case_app case_var go)
  let stop = {indx term}
    [{x}x, (Var 0)]
  dup func = (rec mlen #call #stop)
  # {term}
    (snd (func 0 term))

def term:
  Term.ex
