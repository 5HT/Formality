def VAR: 0
def TYP: 1
def ALL: 2
def LAM: 3
def APP: 4
def BOX: 5
def PUT: 6
def DUP: 7
def UIT: 8
def NUM: 9
def OP1: 10
def OP2: 11
def ITE: 12
def CPY: 13
def SIG: 14
def PAR: 15
def FST: 16
def SND: 17
def PRJ: 18
def SLF: 19
def NEW: 20
def USE: 21
def ANN: 22
def REF: 23

def Var: {index}                    [VAR, {t} (t index)]
def Typ:                            [TYP, {t} t]
def All: {name bind body eras}      [ALL, {t} (t name bind body eras)]
def Lam: {name opt_bind body eras}  [LAM, {t} (t name opt_bind body eras)]
def App: {func argm eras}           [APP, {t} (t func argm eras)]
def Box: {expr}                     [BOX, {t} (t expr)]
def Put: {expr}                     [PUT, {t} (t expr)]
def Dup: {name expr body}           [DUP, {t} (t name expr body)]
def Uit:                            [UIT, {t} t]
def Num: {numb}                     [NUM, {t} (t numb)]
def Op1: {func num0 num1}           [OP1, {t} (t func num0 num1)]
def Op2: {func num0 num1}           [OP2, {t} (t func num0 num1)]
def Ite: {cond pair}                [ITE, {t} (t cond pair)]
def Cpy: {name numb body}           [CPY, {t} (t name numb body)]
def Sig: {name typ0 typ1 eras}      [SIG, {t} (t name typ0 typ1 eras)]
def Par: {val0 val1 eras}           [PAR, {t} (t val0 val1 eras)]
def Fst: {pair eras}                [FST, {t} (t pair eras)]
def Snd: {pair eras}                [SND, {t} (t pair eras)]
def Prj: {nam0 nam1 pair body eras} [PRJ, {t} (t nam0 nam1 pair body eras)]
def Slf: {name type}                [SLF, {t} (t name type)]
def New: {type expr}                [NEW, {t} (t type expr)]
def Use: {expr}                     [USE, {t} (t expr)]
def Ann: {type expr done}           [ANN, {t} (t type expr done)]
def Ref: {name eras}                [REF, {t} (t name eras)]

def Term.match: {term Var Typ All Lam App Box Put Dup Uit Num Op1 Op2 Ite Cpy Sig Par Fst Snd Prj Slf New Use Ann Ref}
  get [tag, fields] = term
  cpy tag = tag
  (fields
  if |tag == 0|
  then: Var
  else: if |tag == 1|
  then: Typ
  else: if |tag == 2|
  then: All
  else: if |tag == 3|
  then: Lam
  else: if |tag == 4|
  then: App
  else: if |tag == 5|
  then: Box
  else: if |tag == 6|
  then: Put
  else: if |tag == 7|
  then: Dup
  else: if |tag == 8|
  then: Uit
  else: if |tag == 9|
  then: Num
  else: if |tag == 10|
  then: Op1
  else: if |tag == 11|
  then: Op2
  else: if |tag == 12|
  then: Ite
  else: if |tag == 13|
  then: Cpy
  else: if |tag == 14|
  then: Sig
  else: if |tag == 15|
  then: Par
  else: if |tag == 16|
  then: Fst
  else: if |tag == 17|
  then: Snd
  else: if |tag == 18|
  then: Prj
  else: if |tag == 19|
  then: Slf
  else: if |tag == 20|
  then: New
  else: if |tag == 21|
  then: Use
  else: if |tag == 22|
  then: Ann
  else: Ref)

def Term.rec:
  (rec ~65536)

def Term.index.copy: (Nat.copy ~256)

def term: Term.ex

def Term.to_string:
  let gen_name = {indx}
    let char = (Num.box_byte ||indx % 26| + 97|)
    (List.cons char List.nil)
  let call = {go depth term}
    cpy depth = depth
    let case_var = {indx} {go}
      let text = List.nil
      let text = (List.concat text (gen_name indx))
      [go, text]
    let case_typ = {go}
      [go, (to_chars "Type")]

    let case_all = {name bind body eras} {go}
      get [go, body] = (go |depth + 1| body)
      get [go, bind] = (go depth bind)
      let text = List.nil
      let text = (List.concat text (to_chars "{"))
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text (List.concat (to_chars " : ") bind))
      let text = (List.concat text (to_chars "} -> "))
      let text = (List.concat text body)
      [go, text]
    let case_lam = {name opt_bind body eras} {go}
      get [go, body] = (go |depth + 1| body)
      get [go, opt_bind] = (opt_bind {go} [go, List.nil]
                                     {bind go}
                                       get [go, bind] = (go depth bind)
                                       [go, (List.concat (to_chars " : ") bind)]
                                     go)
      let text = List.nil
      let text = (List.concat text (to_chars "{"))
      let text = (eras {text} (List.concat text (to_chars "~")) {text} text text)
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text opt_bind)
      let text = (List.concat text (to_chars "} => "))
      let text = (List.concat text body)
      [go, text]
    let case_app = {func argm eras} {go}
      get [go, func] = (go depth func)
      get [go, argm] = (go depth argm)
      let text = List.nil
      let text = (List.concat text (to_chars "("))
      let text = (List.concat text func)
      let text = (List.concat text (to_chars " "))
      let text = (eras {text} (List.concat text (to_chars "~")) {text} text text)
      let text = (List.concat text argm)
      let text = (List.concat text (to_chars ")"))
      [go, text]

    let case_box = {expr} {go}
      let text = List.nil
      let text = (List.concat text (to_chars "!"))
      let text = (List.concat text expr)
      [go, text]
    let case_put = {expr} {go}
      get [go, expr] = (go depth expr)
      let text = List.nil
      let text = (List.concat text (to_chars "#"))
      let text = (List.concat text expr)
      [go, text]
    let case_dup = {name expr body} {go}
      get [go, expr] = (go depth expr)
      get [go, body] = (go |depth + 1| body)
      let text = List.nil
      let text = (List.concat text (to_chars "dup {c"))
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text (to_chars "} = "))
      let text = (List.concat text expr)
      let text = (List.concat text (to_chars "; "))
      let text = (List.concat text body)
      [go, text]

    let case_uit = {go}
      [go, (to_chars "U32")]
    let case_num = {numb} {go}
      [go, (Num.to_chars ~10 numb)]
    let case_op1 = {func num0 num1} {go}
      get [go, num0] = (go depth num0)
      get [go, num1] = (go depth num1)
      let text = List.nil
      let text = (List.concat text (to_chars "|"))
      let text = (List.concat text num0)
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text (to_chars func))
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text num1)
      let text = (List.concat text (to_chars "|"))
      [go, text]
    let case_op2 = {func num0 num1} {go}
      get [go, num0] = (go depth num0)
      get [go, num1] = (go depth num1)
      let text = List.nil
      let text = (List.concat text (to_chars "|"))
      let text = (List.concat text num0)
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text (to_chars func))
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text num1)
      let text = (List.concat text (to_chars "|"))
      [go, text]
    let case_ite = {cond pair} {go}
      get [go, cond] = (go depth cond)
      get [go, pair] = (go depth pair)
      let text = List.nil
      let text = (List.concat text (to_chars "(if "))
      let text = (List.concat text cond)
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text pair)
      let text = (List.concat text (to_chars ")"))
      [go, text]
    let case_cpy = {name numb body} {go}
      get [go, numb] = (go depth numb)
      get [go, body] = (go |depth + 1| body)
      let text = List.nil
      let text = (List.concat text (to_chars "cpy "))
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text (to_chars " = "))
      let text = (List.concat text numb)
      let text = (List.concat text (to_chars "; "))
      let text = (List.concat text body)
      [go, text]

    let case_sig = {name typ0 typ1 eras} {go}
      get [go, typ0] = (go depth typ0)
      get [go, typ1] = (go |depth + 1| typ1)
      let text = List.nil
      let text = (List.concat text (to_chars "["))
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text (to_chars " : "))
      let text = (List.concat text typ0)
      let text = (List.concat text (to_chars (eras " ~ " ",")))
      let text = (List.concat text typ1)
      let text = (List.concat text (to_chars "]"))
      [go, text]
    let case_par = {val0 val1 eras} {go}
      get [go, val0] = (go depth val0)
      get [go, val1] = (go depth val1)
      let text = List.nil
      let text = (List.concat text (to_chars "["))
      let text = (List.concat text val0)
      let text = (List.concat text (to_chars ", "))
      let text = (List.concat text (eras (to_chars "~") List.nil))
      let text = (List.concat text val1)
      let text = (List.concat text (to_chars "]"))
      [go, text]
    let case_fst = {pair eras} {go}
      get [go, pair] = (go depth pair)
      let text = List.nil
      let text = (List.concat text (to_chars "("))
      let text = (List.concat text (eras (to_chars "~") List.nil))
      let text = (List.concat text (to_chars "fst "))
      let text = (List.concat text pair)
      let text = (List.concat text (to_chars ")"))
      [go, text]
    let case_snd = {pair eras} {go}
      get [go, pair] = (go depth pair)
      let text = List.nil
      let text = (List.concat text (to_chars "("))
      let text = (List.concat text (eras (to_chars "~") List.nil))
      let text = (List.concat text (to_chars "snd "))
      let text = (List.concat text pair)
      let text = (List.concat text (to_chars ")"))
      [go, text]
    let case_prj = {nam0 nam1 pair body eras} {go}
      get [go, pair] = (go depth pair)
      get [go, body] = (go |depth + 2| body)
      let text = List.nil
      let text = (List.concat text (to_chars "get ["))
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text (to_chars ", "))
      let text = (List.concat text (eras (to_chars "~") List.nil))
      let text = (List.concat text (gen_name |depth + 1|))
      let text = (List.concat text (to_chars "] = "))
      let text = (List.concat text pair)
      let text = (List.concat text (to_chars "; "))
      let text = (List.concat text body)
      [go, text]

    let case_slf = {name type} {go}
      get [go, type] = (go |depth + 1| type)
      let text = List.nil
      let text = (List.concat text (to_chars "$"))
      let text = (List.concat text (gen_name depth))
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text type)
      [go, text]
    let case_new = {type expr} {go}
      get [go, type] = (go depth type)
      get [go, expr] = (go depth expr)
      let text = List.nil
      let text = (List.concat text (to_chars "@"))
      let text = (List.concat text type)
      let text = (List.concat text (to_chars " "))
      let text = (List.concat text expr)
      [go, text]
    let case_use = {expr} {go}
      get [go, expr] = (go depth expr)
      let text = List.nil
      let text = (List.concat text (to_chars "%"))
      let text = (List.concat text expr)
      [go, text]

    let case_ann = {type expr done} {go}
      (go depth expr)
    let case_ref = {name eras} {go}
      [go, name]
    (Term.match term case_var case_typ case_all case_lam case_app case_box case_put case_dup case_uit case_num case_op1 case_op2 case_ite case_cpy case_sig case_par case_fst case_snd case_prj case_slf case_new case_use case_ann case_ref go)
  let stop = {depth term} [{x}x, term]
  dup func = (Term.rec #call #stop)
  # {term} (from_chars (snd (func 0 term)))

def Term.shift:
  let call = {go inc depth term}
    cpy inc = inc
    cpy depth = depth

    let case_var = {indx} {go}
      cpy indx = indx
      let indx = if |indx < depth| [indx, |indx + inc|]
      [go, (Var indx)]
    let case_typ = {go} [go, Typ]

    let case_all = {name bind body eras} {go}
      get [go, bind] = (go inc depth bind)
      get [go, body] = (go inc |depth + 1| body)
      [go, (All name bind body eras)]
    let case_lam = {name opt_bind body eras} {go}
      get [go, opt_bind] = (opt_bind {go} [go, None]
                                     {bind go}
                                       get [go, bind] = (go inc depth bind)
                                       [go, (Just bind)]
                                     go)
      get [go, body] = (go inc |depth + 1| body)
      [go, (Lam name opt_bind body eras)]
    let case_app = {func argm eras} {go}
      get [go, func] = (go inc depth func)
      get [go, argm] = (go inc depth argm)
      [go, (App func argm eras)]

    let case_box = {expr} {go}
      get [go, expr] = (go inc depth expr)
      [go, (Box expr)]
    let case_put = {expr} {go}
      get [go, expr] = (go inc depth expr)
      [go, (Put expr)]
    let case_dup = {name expr body} {go}
      get [go, expr] = (go inc depth expr)
      get [go, body] = (go inc |depth + 1| body)
      [go, (Dup name expr body)]

    let case_uit = {go} [go, Uit]
    let case_num = {numb} {go} [go, (Num numb)]
    let case_op1 = {func num0 num1} {go}
      get [go, num0] = (go inc depth num0)
      get [go, num1] = (go inc depth num1)
      [go, (Op1 func num0 num1)]
    let case_op2 = {func num0 num1} {go}
      get [go, num0] = (go inc depth num0)
      get [go, num1] = (go inc depth num1)
      [go, (Op2 func num0 num1)]

    let case_ite = {cond pair} {go}
      get [go, cond] = (go inc depth cond)
      get [go, pair] = (go inc depth pair)
      [go, (Ite cond pair)]
    let case_cpy = {name numb body} {go}
      get [go, numb] = (go inc depth numb)
      get [go, body] = (go inc |depth + 1| body)
      [go, (Cpy name numb body)]

    let case_sig = {name typ0 typ1 eras} {go}
      get [go, typ0] = (go inc depth typ0)
      get [go, typ1] = (go inc |depth + 1| typ1)
      [go, (Sig name typ0 typ1 eras)]
    let case_par = {val0 val1 eras} {go}
      get [go, val0] = (go inc depth val0)
      get [go, val1] = (go inc depth val1)
      [go, (Par val0 val1 eras)]
    let case_fst = {pair eras} {go}
      get [go, pair] = (go inc depth pair)
      [go, (Fst pair eras)]
    let case_snd = {pair eras} {go}
      get [go, pair] = (go inc depth pair)
      [go, (Snd pair eras)]
    let case_prj = {nam0 nam1 pair body eras} {go}
      get [go, pair] = (go inc depth pair)
      get [go, body] = (go inc |depth + 2| body)
      [go, (Prj nam0 nam1 pair body eras)]

    let case_slf = {name type} {go}
      get [go, type] = (go inc |depth + 1| type)
      [go, (Slf name type)]
    let case_new = {type expr} {go}
      get [go, type] = (go inc depth type)
      get [go, expr] = (go inc depth expr)
      [go, (New type expr)]
    let case_use = {expr} {go}
      get [go, expr] = (go inc depth expr)
      [go, (Use expr)]

    let case_ann = {type expr done} {go}
      get [go, type] = (go inc depth type)
      get [go, expr] = (go inc depth expr)
      [go, (Ann type expr done)]
    let case_ref = {name eras} {go}
      [go, (Ref name eras)]

    (Term.match term case_var case_typ case_all case_lam case_app case_box case_put case_dup case_uit case_num case_op1 case_op2 case_ite case_cpy case_sig case_par case_fst case_snd case_prj case_slf case_new case_use case_ann case_ref go)
  let stop = {inc depth term} [{x}x, term]
  dup func = (Term.rec #call #stop)
  # {inc depth term} (snd (func inc depth term))

// Term.copy almost complete; still needs to be able to copy strings. Currently passes the empty string as the second element of the pair.
def Term.copy:
  let call = {go term}
    let case_var = {indx} {go}
      cpy indx = indx
      [go, [(Var indx), (Var indx)]]
    let case_typ = {go}
      [go, [Typ, Typ]]

    let case_all = {name bind body eras} {go}
      get [go, bodys]   = (go body)
      get [go, binds]   = (go bind)
      get [body0, body1] = bodys
      get [bind0, bind1] = binds
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(All name bind0 body0 eras0), (All "" bind1 body1 eras1)]]
    let case_lam = {name opt_bind body eras} {go}
      get [go, bodys]   = (go body)
      get [go, opt_binds]   = (opt_bind
                                {go} [go, [None, None]]
                                {bind go} (Pair.prj
                                            (go bind)
                                            {go p} [go, (Pair.prj p {x y} [(Just x),(Just y)])]) go)
      get [body0, body1] = bodys
      get [opt_bind0, opt_bind1] = opt_binds
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Lam name opt_bind0 body0 eras0), (Lam "" opt_bind1 body1 eras1)]]
    let case_app = {func argm eras} {go}
      get [go, funcs]    = (go func)
      get [go, argms]    = (go argm)
      get [func0, func1] = funcs
      get [argm0, argm1] = argms
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(App func0 argm0 eras0), (App func1 argm1 eras1)]]

    let case_box = {expr} {go}
      get [go, exprs]    = (go expr)
      get [expr0, expr1] = exprs
      [go, [(Box expr0), (Box expr1)]]
    let case_put = {expr} {go}
      get [go, exprs]    = (go expr)
      get [expr0, expr1] = exprs
      [go, [(Put expr0), (Put expr1)]]
    let case_dup = {name expr body} {go}
      get [go, exprs]    = (go expr)
      get [go, bodys]    = (go body)
      get [expr0, expr1] = exprs
      get [body0, body1] = bodys
      [go, [(Dup name expr0 body0), (Dup "" expr1 body1)]]

    let case_uit = {go} [go, [Uit, Uit]]
    let case_num = {numb} {go}
      cpy numb = numb
      [go, [(Num numb), (Num numb)]]
    let case_op1 = {func num0 num1} {go}
      cpy num0 = num0
      cpy num1 = num1
      get [go, funcs]    = (go func)
      get [func0, func1] = funcs
      [go, [(Op1 func0 num0 num1), (Op1 func1 num0 num1)]]
    let case_op2 = {func num0 num1} {go}
      cpy num0 = num0
      cpy num1 = num1
      get [go, funcs]    = (go func)
      get [func0, func1] = funcs
      [go, [(Op2 func0 num0 num1), (Op2 func1 num0 num1)]]
    let case_ite = {cond pair} {go}
      get [go, conds]    = (go cond)
      get [go, pairs]    = (go pair)
      get [cond0, cond1] = conds
      get [pair0, pair1] = pairs
      [go, [(Ite cond0 pair0), (Ite cond1 pair1)]]
    let case_cpy = {name numb body} {go}
      cpy numb = numb
      get [go, bodys]    = (go body)
      get [body0, body1] = bodys
      [go, [(Cpy name numb body0), (Cpy "" numb body1)]]

    let case_sig = {name typ0 typ1 eras} {go}
      get [go, typ0s]    = (go typ0)
      get [go, typ1s]    = (go typ1)
      get [typ00, typ01] = typ0s
      get [typ10, typ11] = typ1s
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Sig name typ00 typ10 eras0), (Sig "" typ01 typ11 eras1)]]
    let case_par = {val0 val1 eras} {go}
      get [go, val0s]    = (go val0)
      get [go, val1s]    = (go val1)
      get [val00, val01] = val0s
      get [val10, val11] = val1s
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Par val00 val10 eras0), (Par val01 val11 eras1)]]
    let case_fst = {pair eras} {go}
      get [go, pairs]    = (go pair)
      get [pair0, pair1] = pairs
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Fst pair0 eras0), (Fst pair1 eras1)]]
    let case_snd = {pair eras} {go}
      get [go, pairs]    = (go pair)
      get [pair0, pair1] = pairs
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Snd pair0 eras0), (Snd pair1 eras1)]]
    let case_prj = {nam0 nam1 pair body eras} {go}
      get [go, pairs]    = (go pair)
      get [go, bodys]    = (go body)
      get [pair0, pair1] = pairs
      get [body0, body1] = bodys
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Prj nam0 nam1 pair0 body0 eras0), (Prj "" "" pair1 body1 eras1)]]

    let case_slf = {name type} {go}
      get [go, types]    = (go type)
      get [type0, type1] = types
      [go, [(Slf name type0), (Slf "" type1)]]
    let case_new = {type expr} {go}
      get [go, types]    = (go type)
      get [go, exprs]    = (go expr)
      get [type0, type1] = types
      get [expr0, expr1] = exprs
      [go, [(New type0 expr0), (New type1 expr1)]]
    let case_use = {expr} {go}
      get [go, exprs]    = (go expr)
      get [expr0, expr1] = exprs
      [go, [(Use expr0), (Use expr1)]]

    let case_ann = {type expr done} {go}
      get [go, types]    = (go type)
      get [go, exprs]    = (go expr)
      get [type0, type1] = types
      get [expr0, expr1] = exprs
      get [done0, done1] = (done [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Ann type0 expr0 done0), (Ann type1 expr1 done1)]]
    let case_ref = {name eras} {go}
      get [eras0, eras1] = (eras [Bool.true, Bool.true] [Bool.false, Bool.false])
      [go, [(Ref name eras0), (Ref "" eras1)]]

    (Term.match term case_var case_typ case_all case_lam case_app case_box case_put case_dup case_uit case_num case_op1 case_op2 case_ite case_cpy case_sig case_par case_fst case_snd case_prj case_slf case_new case_use case_ann case_ref go)
  let stop = {term} [{x}x, term]
  dup func = (Term.rec #call #stop)
  # {term} (snd (func term))

def Term.subst:
  dup shift = Term.shift
  dup copy  = Term.copy
  let call = {go inc depth val term}
    cpy depth = depth
    cpy inc   = inc

    let case_var = {indx} {go val}
      cpy indx = indx
      [go, if |indx == depth|
        then: (shift inc 0 val)
        else: (Var |indx - (if |indx > depth| [1,0])|)]
    let case_typ = {go val} [go, Typ]
    let case_all = {name bind body eras} {go val}
      get [val0, val1] = (copy val)
      get [go, bind] = (go inc depth val0 bind)
      get [go, body] = (go |inc + 1| |depth + 1| val1 body)
      [go, (App name bind body eras)]
    let case_lam = {name opt_bind body eras} {go val}
      get [val0, val1] = (copy val)
      get [go, body] = (go |inc + 1| |depth + 1| val0 body)
      get [go, opt_bind] = (opt_bind
                             {go} [go, None]
                             {bind go}
                               get [go, bind] = (go inc depth val1 bind)
                               [go, (Just bind)]
                             go)
      [go, (Lam name opt_bind body eras)]
    let case_app = {func argm eras} {go val}
      get [val0, val1] = (copy val)
      get [go, func]   = (go inc depth val0 func)
      get [go, argm]   = (go inc depth val1 argm)
      [go, (App func argm eras)]

    let case_box = {expr} {go val}
      get [go, expr] = (go inc depth val expr)
      [go, (Box expr)]
    let case_put = {expr} {go val}
      get [go, expr] = (go inc depth val expr)
      [go, (Put expr)]
    let case_dup = {name expr body} {go val}
      get [val0, val1] = (copy val)
      get [go, expr]   = (go inc depth val0 expr)
      get [go, body]   = (go |inc + 1| |depth + 1| val1 body)
      [go, (Dup name expr body)]

    let case_uit = {go val} [go, Uit]
    let case_num = {numb} {go val} [go, (Num numb)]
    let case_op1 = {func num0 num1} {go val}
      get [val0, val1] = (copy val)
      get [go, num0]   = (go inc depth val0 num0)
      get [go, num1]   = (go inc depth val1 num1)
      [go, (Op1 func num0 num1)]
    let case_op2 = {func num0 num1} {go val}
      get [val0, val1] = (copy val)
      get [go, num0]   = (go inc depth val0 num0)
      get [go, num1]   = (go inc depth val1 num1)
      [go, (Op2 func num0 num1)]
    let case_ite = {cond pair} {go val}
      get [val0, val1] = (copy val)
      get [go, cond]   = (go inc depth val0 cond)
      get [go, pair]   = (go inc depth val1 pair)
      [go, (Ite cond pair)]
    let case_cpy = {name numb body} {go val}
      get [val0, val1] = (copy val)
      get [go, numb]   = (go inc depth val0 numb)
      get [go, body]   = (go |inc + 1| |depth + 1| val1 body)
      [go, (Cpy name numb body)]

    let case_sig = {name typ0 typ1 eras} {go val}
      get [val0, val1] = (copy val)
      get [go, typ0]   = (go inc depth val0 typ0)
      get [go, typ1]   = (go |inc + 1| |depth + 1| val1 typ1)
      [go, (Sig name typ0 typ1 eras)]
    let case_par = {par0 par1 eras} {go val}
      get [val0, val1] = (copy val)
      get [go, par0]   = (go inc depth val0 par0)
      get [go, par1]   = (go inc depth val1 par1)
      [go, (Par par0 par1 eras)]
    let case_fst = {pair eras} {go val}
      get [go, pair]   = (go inc depth val pair)
      [go, (Fst pair eras)]
    let case_snd = {pair eras} {go val}
      get [go, pair]   = (go inc depth val pair)
      [go, (Snd pair eras)]
    let case_prj = {nam0 nam1 pair body eras} {go val}
      get [val0, val1] = (copy val)
      get [go, pair]   = (go inc depth val0 pair)
      get [go, body]   = (go |inc + 2| |depth + 2| val1 body)
      [go, (Prj nam0 nam1 pair body eras)]

    let case_slf = {name type} {go val}
      get [go, type]   = (go |inc + 1| |depth + 1| val type)
      [go, (Slf name type)]
    let case_new = {type expr} {go val}
      get [val0, val1] = (copy val)
      get [go, type]   = (go inc depth val0 type)
      get [go, expr]   = (go inc depth val1 expr)
      [go, (New type expr)]
    let case_use = {expr} {go val}
      get [go, expr]   = (go inc depth val expr)
      [go, (Use expr)]

    let case_ann = {type expr done} {go val}
      get [val0, val1] = (copy val)
      get [go, type]   = (go inc depth val0 type)
      get [go, expr]   = (go inc depth val1 expr)
      [go, (Ann type expr done)]
    let case_ref = {name eras} {go val}
      [go, (Ref name eras)]

    (Term.match term case_var case_typ case_all case_lam case_app case_box case_put case_dup case_uit case_num case_op1 case_op2 case_ite case_cpy case_sig case_par case_fst case_snd case_prj case_slf case_new case_use case_ann case_ref go val)
  let stop = {inc depth val term}
    [{x}x, term]
  dup func = (Term.rec #call #stop)
  # {depth val term}
    (snd (func 0 depth val term))

def Term.ex:
  // Library functions
  dup to_string = Term.to_string
  dup shift     = Term.shift
  dup subst     = Term.subst
  dup copy      = Term.copy
  //dup reduce    = Term.reduce

  //Example terms
  # (to_string (subst 0 (Lam "A" (Just Typ) (Lam "x" (Just (Var 0)) (App (Var 2) (Var 1) Bool.false) Bool.false) Bool.true) (App (Var 0) (Var 0) Bool.false)))