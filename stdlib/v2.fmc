def V2.rect.ex: {cons}
  dup cons = cons
  dup area = (V2.rect ~16 #[4,4] #cons)
  # (area [100,100])

// Approximates pi
def V2.ex: 
  let srad = 1200
  let form = (V2.circle ~5000 #srad)
  let hits = {pos num} |1 + num|
  dup circ = (form #hits)
  # ||(circ [256,256] 0) * 1000000| / srad|

// V2.add
// | Receives two 2D vectors and adds them
// : {a : [Num,Num]}
//   {b : [Num,Num]}
//   [Num,Num]
def V2.add: {a b}
  get [ax,ay] = a
  get [bx,by] = b
  [|ax + bx|, |ay + by|]

// V2.scale
def V2.scale: {a s}
  get [ax,ay] = a
  [|ax * s|, |ay * s|]

// V2.neg
// | Negates a 2D vector
// : {a : [Num,Num]}
//   [Num,Num]
def V2.neg: {a}
  get [ax,ay] = a
  [|0 - ax|, |0 - ay|]

// V2.cpy
// | Copies a 2D vector
// : {a : [Num,Num]}
//   {b : [Num,Num]}
//   [[Num,Num], [Num,Num]]
def V2.cpy: {a}
  get [ax,ay] = a
  cpy ax      = ax
  cpy ay      = ay
  [[ax,ay], [ax,ay]]

// V2.sqr_dist
// : {a : [Num,Num]}
//   {b : [Num,Num]}
//   Num
def V2.sqr_dist: {a b}
  get [ax,ay] = a
  get [bx,by] = b
  cpy dx = |(Num.dif ax bx) ** 2|
  cpy dy = |(Num.dif ay by) ** 2|
  |dx + dy|

// V2.dist
// : {a : [Num,Num]}
//   {b : [Num,Num]}
//   Num
def V2.dist: {a b}
  (Num.sqrt (V2.sqr_dist a b))

// V2.flat_dist
// : {a : [Num,Num]}
//   {b : [Num,Num]}
//   Num
def V2.flat_dist: {a b}
  get [ax,ay] = a
  get [bx,by] = b
  |(Num.dif ax bx) + (Num.dif ay by)|

// V2.line
// | Up to `max_len`, given a length `len`, a center pos `pos`, and a displacement
// | vector `dxy`, returns vectors from `pos`, incrementing by `dxy`, `len` times.
// : {max_len : Nat}
//   {-P      : Type}
//   {cons    : ! {x : [Num,Num]} {xs : P} P}
// ! {len     : Num}
//   {pos     : [Num,Num]}
//   {dxy     : [Num,Num]}
//   {nil     : P}
//   P
def V2.line: {max_len} {cons}
  dup cons = cons
  dup fold = (max_len #{list len pos dxy}
    get [ax,ay] = pos
    get [dx,dy] = dxy
    cpy len = len
    cpy ax  = ax
    cpy ay  = ay
    cpy dx  = dx
    cpy dy  = dy
    (if |len == 0|
      then: {list} (list 0 [0,0] [0,0])
      else: {list} (cons [ax,ay] (list |len - 1| [|ax + dx|,|ay + dy|] [dx,dy]))
      list))
  # {len pos dxy nil}
    (fold {len pos dxy}nil len pos dxy)

// V2.area
// : {mlen : Nat}
//   {-P   : Type}
//   {size : [Num,Num]}
//   {cond : ! {x : [Num,Num]} Num}
//   {cons : ! {x : [Num,Num]} {xs : P} P}
// ! {pos  : [Num,Num]}
//   {siz  : [Num,Num]}
//   {nil  : P}
//   P
def V2.area: {mlen size cond} {cons}
  dup cons = cons
  dup size = size
  dup cond = cond
  dup fold = (mlen #{list pos idx}
    get [cx,cy] = pos
    get [sx,sy] = size
    cpy sx = sx
    cpy sy = sy
    cpy cx = cx
    cpy cy = cy
    cpy ix = idx
    cpy px = ||cx + |ix % sx|| - |sx / 2||
    cpy py = ||cy + |ix / sx|| - |sy / 2||
    let fn = (if (cond [cx,cy] [sx,sy] [px,py]) [(cons [px,py]),{x}x])
    let xs = (list [cx,cy] |ix + 1|)
    (fn xs))
  # {pos nil}
    (fold {pos idx}nil pos 0)

// V2.rect
// : {mlen : Nat}
//   {-P   : Type}
//   {size : [Num,Num]}
//   {cons : ! {x : [Num,Num]} {xs : P} P}
// ! {pos  : [Num,Num]}
//   {siz  : [Num,Num]}
//   {nil  : P}
//   P
def V2.rect: {mlen size}
  (V2.area mlen size #{cen siz pos}1)

//V2.circle
// : {mlen : Nat}
//   {-P   : Type}
//   {mlen : Nat}
//   {srad : Num} -- squared radius
//   {cons : ! {pos : [Num,Num]} {state : P} P}
// ! {pos  : [Num,Num]}
//   {nil  : P}
//   P
def V2.circle: {mlen srad cons}
  dup cons = cons
  dup srad = srad
  let isin = {cen siz pos} |(V2.sqr_dist cen pos) < srad|
  dup size = #||(Num.sqrt srad) * 2| + 1|
  dup area = (V2.area mlen #[size,size] #isin #cons)
  # {pos} (area pos)

// . . .
// . x .
// . . .
def V2.circle_a: (V2.circle ~1 #1)

// . . . . .
// . . x . .
// . x x x .
// . . x . .
// . . . . .
def V2.circle_b: (V2.circle ~9 #2)

// . . . . .
// . x x x .
// . x x x .
// . x x x .
// . . . . .
def V2.circle_c: (V2.circle ~9 #3)

// . . . . . . .
// . . . x . . .
// . . x x x . .
// . x x x x x .
// . . x x x . .
// . . . x . . .
// . . . . . . .
def V2.circle_d: (V2.circle ~25 #5)

// . . . . . . .
// . . x x x . .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . . x x x . .
// . . . . . . .
def V2.circle_e: (V2.circle ~25 #6)

// . . . . . . .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . . . . . . .
def V2.circle_f: (V2.circle ~49 #9)

// . . . . . . . . .
// . . . . x . . . .
// . . x x x x x . .
// . . x x x x x . .
// . x x x x x x x .
// . . x x x x x . .
// . . x x x x x . .
// . . . . x . . . .
// . . . . . . . . .
def V2.circle_g: (V2.circle ~49 #10)

// . . . . . . . . .
// . . . x x x . . .
// . . x x x x x . .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . . x x x x x . .
// . . . x x x . . .
// . . . . . . . . .
def V2.circle_h: (V2.circle ~49 #11)

// . . . . . . . . .
// . . x x x x x . .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . . x x x x x . .
// . . . . . . . . .
def V2.circle_i: (V2.circle ~49 #14)

// . . . . . . . . . . .
// . . . . . x . . . . .
// . . . x x x x x . . .
// . . x x x x x x x . .
// . . x x x x x x x . .
// . x x x x x x x x x .
// . . x x x x x x x . .
// . . x x x x x x x . .
// . . . x x x x x . . .
// . . . . . x . . . . .
// . . . . . . . . . . .
def V2.circle_j: (V2.circle ~81 #17)

//V2.range
// : {mlen : Nat}
//   {-P   : Type}
//   {rad  : Num} -- radius
//   {cons : ! {pos : [Num,Num]} {state : P} P}
// ! {pos  : [Num,Num]}
//   {nil  : P}
//   P
def V2.range: {mlen rad cons}
  dup cons = cons
  dup rad  = rad
  let isin = {cen siz pos} |(V2.flat_dist cen pos) < |rad + 1||
  dup size = # ||rad * 2| + 1|
  dup area = (V2.area mlen #[size,size] #isin #cons)
  # {pos} (area pos)

def V2.range_0: (V2.range ~1 #0)
def V2.range_1: (V2.range ~9 #1)
def V2.range_2: (V2.range ~25 #2)
def V2.range_3: (V2.range ~49 #3)
def V2.range_4: (V2.range ~81 #4)
def V2.range_5: (V2.range ~121 #5)
def V2.range_6: (V2.range ~169 #6)

// V2.wave
// | Given a list of widths, returns vectors filling a wave from `pos` pointing to `dir`.
// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}
//   {-P     : Type}
//   {cons   : ! {pos : [Num,Num]} {res : P} P}
// ! {pos    : [Num,Num]}
//   {dxy    : [Num,Num]}
//   {nil    : P}
//   P
def V2.wave: {widths} {cons}
  dup cons = cons
  dup line = (V2.line ~7 #cons)
  dup fold = (widths #{w ws pos dxy}
    get [ax,ay] = pos
    get [dx,dy] = dxy
    cpy w  = w
    cpy ax = ax
    cpy ay = ay
    cpy dx = dx
    cpy dy = dy
    cpy nx = dy
    cpy ny = |0 - dx|
    let ix = |ax - |nx * |w / 2||| 
    let iy = |ay - |ny * |w / 2|||
    let t  = (ws [|ax + dx|,|ay + dy|] [dx,dy])
    (line w [ix,iy] [nx,ny] t))
  # {pos dxy nil}
    (fold {pos dxy}nil pos dxy)

// V2.wave_out
// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}
//   {-P     : Type}
//   {cons   : ! {pos_dir : [[Num,Num],[Num,Num]]} {res : P} P}
// ! {pos    : [Num,Num]}
//   {dxy    : [Num,Num]}
//   {nil    : P}
//   P
def V2.wave_out: {widths} {cons} 
  dup cons = cons
  dup wave = (V2.wave widths #{pos rest dxy}
    get [dxy0,dxy1] = (V2.cpy dxy)
    (cons [pos,dxy0] (rest dxy1)))
  # {pos dxy nil}
    get [dxy0,dxy1] = (V2.cpy dxy)
    (wave pos dxy0 {dxy}nil dxy1)

// V2.wave_in
// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}
//   {-P     : Type}
//   {cons   : ! {pos_dir : [[Num,Num],[Num,Num]]} {res : P} P}
// ! {pos    : [Num,Num]}
//   {dxy    : [Num,Num]}
//   {nil    : P}
//   P
def V2.wave_in: {widths} {cons} 
  dup cons = cons
  dup wave = (V2.wave widths #{pos rest res dxy}
    get [dxy0,dxy1] = (V2.cpy dxy)
    (rest (cons [pos,dxy0] res) dxy1))
  # {pos dxy nil}
    get [dxy0,dxy1] = (V2.cpy dxy)
    (wave pos dxy0 {res dxy}res nil (V2.neg dxy1))

def v2: V2.ex
